---
const { brightness = 0.9, speed = 1 } = Astro.props;
---

<canvas
  id="grid-bg"
  class="grid-canvas"
  data-brightness={brightness}
  data-speed={speed}></canvas>

<style>
  .grid-canvas {
    position: fixed;
    inset: 0;
    width: 100%;
    height: 100%;
    z-index: -3;
    pointer-events: none;
    display: block;
  }
</style>

<script is:inline>
  (() => {
    const canvas = document.getElementById("grid-bg");
    const ctx = canvas.getContext("2d");

    // Config
    const BRIGHTNESS = Math.max(
      0.4,
      Math.min(1.2, Number(canvas.dataset.brightness || 0.9)),
    );
    const SPEED = Math.max(0.3, Math.min(2, Number(canvas.dataset.speed || 1)));

    // Theme-aware colors
    let isDarkMode =
      !document.documentElement.hasAttribute("data-theme") ||
      document.documentElement.getAttribute("data-theme") !== "light";

    // Color schemes for dark and light modes
    const DARK_COLORS = {
      bg: "#0a0e14",
      transmissionLine: "rgba(50, 210, 122, 0.22)",
      transmissionLineGlow: "rgba(50, 210, 122, 0.06)",
      substation: "#32d27a",
      generator: "#7cc7ff",
      load: "#f6b26b",
      powerFlow: "rgba(50, 210, 122, 0.9)",
      powerFlowGlow: "rgba(50, 210, 122, 0.35)",
    };

    const LIGHT_COLORS = {
      bg: "#f9fafb",
      transmissionLine: "rgba(16, 185, 129, 0.30)",
      transmissionLineGlow: "rgba(16, 185, 129, 0.10)",
      substation: "#10b981",
      generator: "#0891b2",
      load: "#f59e0b",
      powerFlow: "rgba(16, 185, 129, 0.90)",
      powerFlowGlow: "rgba(16, 185, 129, 0.35)",
    };

    let COLORS = isDarkMode ? DARK_COLORS : LIGHT_COLORS;

    // Listen for theme changes
    window.addEventListener("themechange", (e) => {
      isDarkMode = e.detail.theme !== "light";
      COLORS = isDarkMode ? DARK_COLORS : LIGHT_COLORS;
    });

    // State
    let W = 0,
      H = 0,
      DPR = 1;
    let substations = [];
    let transmissionLines = [];
    let powerFlows = [];
    let lastTime = 0;

    // Resize handler
    function resize() {
      DPR = Math.min(2, window.devicePixelRatio || 1);
      W = canvas.clientWidth;
      H = canvas.clientHeight;
      canvas.width = Math.floor(W * DPR);
      canvas.height = Math.floor(H * DPR);
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
      generateGrid();
    }

    // Generate electrical grid layout - REDUCED DENSITY
    function generateGrid() {
      substations = [];
      transmissionLines = [];
      powerFlows = [];

      // Larger cell size = fewer nodes (was 150, now 220)
      const cols = Math.floor(W / 220) + 1;
      const rows = Math.floor(H / 220) + 1;
      const cellW = W / cols;
      const cellH = H / rows;

      for (let row = 0; row <= rows; row++) {
        for (let col = 0; col <= cols; col++) {
          // Skip more nodes for sparser feel (was 0.2, now 0.35)
          if (Math.random() < 0.35) continue;

          const x = col * cellW + (Math.random() - 0.5) * cellW * 0.3;
          const y = row * cellH + (Math.random() - 0.5) * cellH * 0.3;

          // Node types: substations (main), generators (power source), loads (consumption)
          const types = ["substation", "generator", "load"];
          const weights = [0.65, 0.2, 0.15];
          const rand = Math.random();
          let type = "substation";
          if (rand > weights[0]) type = "generator";
          if (rand > weights[0] + weights[1]) type = "load";

          substations.push({
            x,
            y,
            type,
            size:
              type === "generator"
                ? 4 + Math.random() * 2
                : 3 + Math.random() * 1.5,
            pulseOffset: Math.random() * Math.PI * 2,
            pulseSpeed: 0.3 + Math.random() * 0.3,
            voltage: 0.7 + Math.random() * 0.3,
          });
        }
      }

      // Connect nearby substations with transmission lines - fewer connections
      for (let i = 0; i < substations.length; i++) {
        const a = substations[i];
        for (let j = i + 1; j < substations.length; j++) {
          const b = substations[j];
          const dist = Math.hypot(b.x - a.x, b.y - a.y);

          // Smaller connection radius and lower probability
          const connectionChance =
            a.type === "generator" || b.type === "generator"
              ? 0.35
              : a.type === "load" || b.type === "load"
                ? 0.25
                : 0.2;

          if (dist < 280 && Math.random() < connectionChance) {
            transmissionLines.push({
              from: i,
              to: j,
              alpha: 0.18 + Math.random() * 0.1,
              thickness: 1 + Math.random() * 0.5,
              pulseOffset: Math.random() * Math.PI * 2,
            });
          }
        }
      }

      // Initialize power flow particles - fewer per line
      initPowerFlows();
    }

    // Initialize power flow particles
    function initPowerFlows() {
      powerFlows = [];
      for (const line of transmissionLines) {
        // Only 1 power flow per line (was 1-3)
        if (Math.random() < 0.6) {
          powerFlows.push({
            lineIndex: transmissionLines.indexOf(line),
            progress: Math.random(),
            speed: (0.12 + Math.random() * 0.15) * SPEED,
            size: 2 + Math.random() * 1.5,
            brightness: 0.5 + Math.random() * 0.4,
          });
        }
      }
    }

    // Get node color based on type
    function getNodeColor(type) {
      switch (type) {
        case "generator":
          return COLORS.generator;
        case "load":
          return COLORS.load;
        default:
          return COLORS.substation;
      }
    }

    // Draw background - different approach for light vs dark
    function drawBackgroundGrid() {
      ctx.fillStyle = COLORS.bg;
      ctx.fillRect(0, 0, W, H);

      if (isDarkMode) {
        // Dark mode: subtle grid structure
        ctx.strokeStyle = "rgba(50, 210, 122, 0.025)";
        ctx.lineWidth = 1;
        const gridSize = 60;

        ctx.beginPath();
        for (let x = 0; x <= W; x += gridSize) {
          ctx.moveTo(x, 0);
          ctx.lineTo(x, H);
        }
        for (let y = 0; y <= H; y += gridSize) {
          ctx.moveTo(0, y);
          ctx.lineTo(W, y);
        }
        ctx.stroke();
      } else {
        // Light mode: subtle emerald gradient accents
        const gradient = ctx.createRadialGradient(
          W * 0.3,
          H * 0.2,
          0,
          W * 0.3,
          H * 0.2,
          W * 0.8,
        );
        gradient.addColorStop(0, "rgba(16, 185, 129, 0.035)");
        gradient.addColorStop(0.5, "rgba(16, 185, 129, 0.012)");
        gradient.addColorStop(1, "transparent");
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, W, H);

        // Second subtle gradient - cyan accent
        const gradient2 = ctx.createRadialGradient(
          W * 0.8,
          H * 0.7,
          0,
          W * 0.8,
          H * 0.7,
          W * 0.6,
        );
        gradient2.addColorStop(0, "rgba(8, 145, 178, 0.025)");
        gradient2.addColorStop(1, "transparent");
        ctx.fillStyle = gradient2;
        ctx.fillRect(0, 0, W, H);
      }
    }

    // Draw transmission lines between substations
    function drawTransmissionLines(time) {
      for (const line of transmissionLines) {
        const a = substations[line.from];
        const b = substations[line.to];

        const pulse =
          0.8 + 0.2 * Math.sin(time * 0.0006 * SPEED + line.pulseOffset);
        const alpha = line.alpha * pulse * BRIGHTNESS;

        // Draw glow behind line
        ctx.strokeStyle = COLORS.transmissionLineGlow;
        ctx.globalAlpha = alpha * 0.5;
        ctx.lineWidth = line.thickness + 3;
        ctx.beginPath();
        ctx.moveTo(a.x, a.y);
        ctx.lineTo(b.x, b.y);
        ctx.stroke();

        // Draw main transmission line
        ctx.strokeStyle = COLORS.transmissionLine;
        ctx.globalAlpha = alpha;
        ctx.lineWidth = line.thickness;
        ctx.beginPath();
        ctx.moveTo(a.x, a.y);
        ctx.lineTo(b.x, b.y);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
    }

    // Draw power flow animation along lines
    function drawPowerFlows(time, deltaTime) {
      for (const flow of powerFlows) {
        const line = transmissionLines[flow.lineIndex];
        if (!line) continue;

        const a = substations[line.from];
        const b = substations[line.to];

        // Update progress
        flow.progress += flow.speed * deltaTime * 0.001;
        if (flow.progress > 1) {
          flow.progress = 0;
        }

        // Calculate position along line
        const x = a.x + (b.x - a.x) * flow.progress;
        const y = a.y + (b.y - a.y) * flow.progress;

        // Draw power flow glow
        const gradient = ctx.createRadialGradient(
          x,
          y,
          0,
          x,
          y,
          flow.size * 3.5,
        );
        gradient.addColorStop(0, COLORS.powerFlowGlow);
        gradient.addColorStop(1, "transparent");
        ctx.fillStyle = gradient;
        ctx.globalAlpha = flow.brightness * BRIGHTNESS;
        ctx.beginPath();
        ctx.arc(x, y, flow.size * 3.5, 0, Math.PI * 2);
        ctx.fill();

        // Draw power flow core
        ctx.fillStyle = COLORS.powerFlow;
        ctx.globalAlpha = flow.brightness * BRIGHTNESS;
        ctx.beginPath();
        ctx.arc(x, y, flow.size, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;
    }

    // Draw substation nodes
    function drawSubstations(time) {
      for (const node of substations) {
        const pulse =
          0.75 +
          0.25 *
            Math.sin(
              time * 0.0015 * SPEED * node.pulseSpeed + node.pulseOffset,
            );
        const size = node.size * pulse;
        const color = getNodeColor(node.type);

        // Draw outer glow
        const gradient = ctx.createRadialGradient(
          node.x,
          node.y,
          0,
          node.x,
          node.y,
          size * 4.5,
        );
        gradient.addColorStop(0, color);
        gradient.addColorStop(1, "transparent");
        ctx.fillStyle = gradient;
        ctx.globalAlpha = 0.1 * BRIGHTNESS * node.voltage;
        ctx.beginPath();
        ctx.arc(node.x, node.y, size * 4.5, 0, Math.PI * 2);
        ctx.fill();

        // Draw middle glow
        ctx.beginPath();
        ctx.arc(node.x, node.y, size * 2, 0, Math.PI * 2);
        ctx.fillStyle = color;
        ctx.globalAlpha = 0.12 * BRIGHTNESS * node.voltage;
        ctx.fill();

        // Draw core
        ctx.beginPath();
        ctx.arc(node.x, node.y, size, 0, Math.PI * 2);
        ctx.fillStyle = color;
        ctx.globalAlpha = 0.65 * BRIGHTNESS * node.voltage;
        ctx.fill();

        // Draw bright center for generators
        if (node.type === "generator") {
          ctx.beginPath();
          ctx.arc(node.x, node.y, size * 0.35, 0, Math.PI * 2);
          ctx.fillStyle = "#ffffff";
          ctx.globalAlpha = 0.35 * BRIGHTNESS;
          ctx.fill();
        }
      }
      ctx.globalAlpha = 1;
    }

    // Animation loop
    let raf = 0;
    function frame(time) {
      const deltaTime = Math.min(time - lastTime, 100); // Cap delta to prevent jumps
      lastTime = time;

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawBackgroundGrid();
      drawTransmissionLines(time);
      drawPowerFlows(time, deltaTime);
      drawSubstations(time);
      raf = requestAnimationFrame(frame);
    }

    // Init
    window.addEventListener("resize", resize);
    resize();
    raf = requestAnimationFrame(frame);

    // Pause when hidden
    document.addEventListener("visibilitychange", () => {
      if (document.hidden) {
        cancelAnimationFrame(raf);
      } else {
        lastTime = performance.now();
        raf = requestAnimationFrame(frame);
      }
    });
  })();
</script>
